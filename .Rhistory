#| label: ciclo-economico
#| fig-width: 10
#| fig-height: 6
library(ggplot2)
library(dplyr)
# Crear datos para la curva del ciclo económico
tiempo <- seq(0, 100, length.out = 200)
pib <- 50 + 30 * sin(tiempo/15 - pi/2) + tiempo/8
df <- data.frame(tiempo = tiempo, pib = pib)
# Definir las fases del ciclo con sus límites
fases <- data.frame(
fase = c("Expansión", "Boom", "Recesión", "Depresión"),
xmin = c(0, 20, 35, 55),
xmax = c(20, 35, 55, 100),
color = c("#FFB6C6", "#FFFF99", "#C8D6B9", "#FFD4A3")
)
# Crear el gráfico
ggplot(df, aes(x = tiempo, y = pib)) +
# Agregar rectángulos de fondo para cada fase
geom_rect(data = fases,
aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fase),
inherit.aes = FALSE, alpha = 0.6) +
# Línea del ciclo económico
geom_line(color = "#00008B", size = 1.5) +
# Colores personalizados
scale_fill_manual(values = c("Expansión" = "#FFB6C6",
"Boom" = "#FFFF99",
"Recesión" = "#C8D6B9",
"Depresión" = "#FFD4A3"),
breaks = c("Expansión", "Boom", "Recesión", "Depresión")) +
# Etiquetas
labs(x = "Tiempo",
y = "Producto Interno Bruto",
fill = NULL) +
# Tema limpio
theme_minimal() +
theme(
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
legend.position = "top",
legend.text = element_text(size = 12),
axis.title = element_text(size = 12, face = "bold"),
plot.margin = margin(20, 20, 20, 20)
) +
guides(fill = guide_legend(nrow = 1))
#| label: ciclo-economico
#| fig-width: 10
#| fig-height: 6
library(ggplot2)
library(dplyr)
# Crear datos para la curva del ciclo económico
tiempo <- seq(0, 100, length.out = 200)
pib <- 50 + 30 * sin(tiempo/15 - pi/2) + tiempo/8
df <- data.frame(tiempo = tiempo, pib = pib)
# Definir las fases del ciclo con sus límites
fases <- data.frame(
fase = c("Expansión", "Boom", "Recesión", "Depresión"),
xmin = c(0, 20, 35, 55),
xmax = c(20, 35, 55, 100),
color = c("#FFB6C6", "#FFFF99", "#C8D6B9", "#FFD4A3")
)
# Crear el gráfico
ggplot(df, aes(x = tiempo, y = pib)) +
# Agregar rectángulos de fondo para cada fase
geom_rect(data = fases,
aes(xmin = xmin, xmax = xmax, ymin = -Inf, ymax = Inf, fill = fase),
inherit.aes = FALSE, alpha = 0.6) +
# Línea del ciclo económico
geom_line(color = "#00008B", size = 1.5) +
# Colores personalizados
scale_fill_manual(values = c("Expansión" = "#FFB6C6",
"Boom" = "#FFFF99",
"Recesión" = "#C8D6B9",
"Depresión" = "#FFD4A3"),
breaks = c("Expansión", "Boom", "Recesión", "Depresión")) +
labs(x = "Tiempo",
y = "Producto Interno Bruto",
fill = NULL,
caption = "Elaborado por n0dn 2025") +
# Tema limpio
theme_minimal() +
theme(
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank(),
legend.position = "top",
legend.text = element_text(size = 12),
axis.title = element_text(size = 12, face = "bold"),
plot.margin = margin(20, 20, 20, 20)
) +
guides(fill = guide_legend(nrow = 1))
#| label: red-libre-escala
#| fig-width: 10
#| fig-height: 10
library(igraph)
# Establecer semilla para reproducibilidad
set.seed(123)
# Crear red libre de escala usando el modelo Barabási-Albert
# 42 nodos, cada nuevo nodo se conecta con 2 nodos existentes
red <- barabasi.game(n = 42,
power = 1,
m = 2,
directed = FALSE)
# Calcular el layout Fruchterman-Reingold
layout_fr <- layout_with_fr(red)
# Calcular grado de cada nodo para tamaño visual
grado <- degree(red)
# Calcular betweenness para color
betweenness_val <- betweenness(red)
colores <- colorRampPalette(c("#3498db", "#e74c3c"))(100)
indices_color <- cut(betweenness_val, breaks = 100, labels = FALSE)
colores_nodos <- colores[indices_color]
# Visualizar la red
plot(red,
layout = layout_fr,
vertex.size = sqrt(grado) * 3,
vertex.color = colores_nodos,
vertex.frame.color = "white",
vertex.label = NA,
edge.color = "gray70",
edge.width = 0.8,
main = "Red Libre de Escala (42 nodos)\nLayout Fruchterman-Reingold")
# Agregar leyenda
legend("topright",
legend = c("Hub (alto grado)", "Nodo periférico (bajo grado)"),
pch = 21,
pt.bg = c("#e74c3c", "#3498db"),
pt.cex = c(2.5, 1.5),
cex = 0.8,
bty = "n")
#| label: red-libre-escala
#| fig-width: 10
#| fig-height: 10
#| warning: false
#| message: false
#| fig-cap: "Elaborado por n0dn, 2025"
library(igraph)
# Establecer semilla para reproducibilidad
set.seed(123)
# Crear red libre de escala usando el modelo Barabási-Albert
# 42 nodos, cada nuevo nodo se conecta con 2 nodos existentes
red <- barabasi.game(n = 42,
power = 1,
m = 2,
directed = FALSE)
# Calcular el layout Fruchterman-Reingold
layout_fr <- layout_with_fr(red)
# Calcular grado de cada nodo para tamaño visual
grado <- degree(red)
# Calcular betweenness para color
betweenness_val <- betweenness(red)
colores <- colorRampPalette(c("#3498db", "#e74c3c"))(100)
indices_color <- cut(betweenness_val, breaks = 100, labels = FALSE)
colores_nodos <- colores[indices_color]
# Visualizar la red
plot(red,
layout = layout_fr,
vertex.size = sqrt(grado) * 3,
vertex.color = colores_nodos,
vertex.frame.color = "white",
vertex.label = NA,
edge.color = "gray70",
edge.width = 0.8,
main = "Ejemplo de una red libre de escala con 42 nodos")
legend("topright",
legend = c("Hub (alto grado)", "Nodo periférico (bajo grado)"),
pch = 21,
pt.bg = c("#e74c3c", "#3498db"),
pt.cex = c(2.5, 1.5),
cex = 0.8,
bty = "n")
n_nodos <- vcount(red)
n_aristas <- ecount(red)
cat("1. ESTRUCTURA BÁSICA:\n")
cat(sprintf("   - Número de nodos: %d\n", n_nodos))
cat(sprintf("   - Número de aristas (vértices): %d\n", n_aristas))
# 2. Densidad de la red
densidad <- edge_density(red)
cat(sprintf("\n2. DENSIDAD DE LA RED: %.4f\n", densidad))
cat(sprintf("   (%.2f%% de las posibles conexiones)\n", densidad * 100))
# 3. Caminos cortos (geodésicas)
distancias <- distances(red)
camino_promedio <- mean_distance(red)
diametro <- diameter(red)
cat(sprintf("\n3. CAMINOS CORTOS (GEODÉSICAS):\n"))
cat(sprintf("   - Longitud promedio del camino: %.4f\n", camino_promedio))
cat(sprintf("   - Diámetro de la red: %d\n", diametro))
# 4. Grado de centralidad
grados <- degree(red)
grado_promedio <- mean(grados)
grado_max <- max(grados)
grado_min <- min(grados)
cat(sprintf("\n4. GRADO DE CENTRALIDAD:\n"))
cat(sprintf("   - Grado promedio: %.4f\n", grado_promedio))
cat(sprintf("   - Grado máximo: %d\n", grado_max))
cat(sprintf("   - Grado mínimo: %d\n", grado_min))
cat(sprintf("   - Desviación estándar: %.4f\n", sd(grados)))
# 5. Coeficiente de agrupamiento (clustering)
clustering_global <- transitivity(red, type = "global")
clustering_promedio <- transitivity(red, type = "average")
clustering_local <- transitivity(red, type = "local")
cat(sprintf("\n5. COEFICIENTE DE AGRUPAMIENTO (CLUSTERING):\n"))
cat(sprintf("   - Clustering global: %.4f\n", clustering_global))
cat(sprintf("   - Clustering promedio: %.4f\n", clustering_promedio))
cat(sprintf("   - Clustering local (rango): %.4f - %.4f\n",
min(clustering_local, na.rm = TRUE),
max(clustering_local, na.rm = TRUE)))
# 6. Otras métricas de centralidad
betweenness_promedio <- mean(betweenness(red))
closeness_promedio <- mean(closeness(red))
cat(sprintf("\n6. OTRAS MÉTRICAS DE CENTRALIDAD:\n"))
cat(sprintf("   - Betweenness promedio: %.4f\n", betweenness_promedio))
cat(sprintf("   - Closeness promedio: %.4f\n", closeness_promedio))
# 7. Propiedades de red libre de escala
cat(sprintf("\n7. CARACTERÍSTICAS DE RED LIBRE DE ESCALA:\n"))
cat(sprintf("   - Número de hubs (grado > promedio): %d\n",
sum(grados > grado_promedio)))
cat(sprintf("   - Proporción de hubs: %.2f%%\n",
100 * sum(grados > grado_promedio) / n_nodos))
cat("\n==========================================\n")
#| label: red-libre-escala
#| fig-width: 10
#| fig-height: 10
#| warning: false
#| message: false
#| fig-cap: "Elaborado por n0dn, 2025"
library(igraph)
# Establecer semilla para reproducibilidad
set.seed(123)
# Crear red libre de escala usando el modelo Barabási-Albert
# 42 nodos, cada nuevo nodo se conecta con 2 nodos existentes
red <- barabasi.game(n = 42,
power = 1,
m = 2,
directed = FALSE)
# Calcular el layout Fruchterman-Reingold
layout_fr <- layout_with_fr(red)
# Calcular grado de cada nodo para tamaño visual
grado <- degree(red)
# Calcular betweenness para color
betweenness_val <- betweenness(red)
colores <- colorRampPalette(c("#3498db", "#e74c3c"))(100)
indices_color <- cut(betweenness_val, breaks = 100, labels = FALSE)
colores_nodos <- colores[indices_color]
# Visualizar la red
plot(red,
layout = layout_fr,
vertex.size = sqrt(grado) * 3,
vertex.color = colores_nodos,
vertex.frame.color = "white",
vertex.label = NA,
edge.color = "gray70",
edge.width = 0.8,
main = "Ejemplo de una red libre de escala con 42 nodos")
legend("topright",
legend = c("Hub (alto grado)", "Nodo periférico (bajo grado)"),
pch = 21,
pt.bg = c("#e74c3c", "#3498db"),
pt.cex = c(2.5, 1.5),
cex = 0.8,
bty = "n")
# ============================================
# ANÁLISIS DESCRIPTIVO DE LA RED
# ============================================
cat("\n=== ANÁLISIS DESCRIPTIVO DE LA RED ===\n\n")
# 1. Número de nodos y aristas
n_nodos <- vcount(red)
n_aristas <- ecount(red)
cat("1. ESTRUCTURA BÁSICA:\n")
cat(sprintf("   - Número de nodos: %d\n", n_nodos))
cat(sprintf("   - Número de aristas (vértices): %d\n", n_aristas))
# 2. Densidad de la red
densidad <- edge_density(red)
cat(sprintf("\n2. DENSIDAD DE LA RED: %.4f\n", densidad))
cat(sprintf("   (%.2f%% de las posibles conexiones)\n", densidad * 100))
# 3. Caminos cortos (geodésicas)
distancias <- distances(red)
camino_promedio <- mean_distance(red)
diametro <- diameter(red)
cat(sprintf("\n3. CAMINOS CORTOS (GEODÉSICAS):\n"))
cat(sprintf("   - Longitud promedio del camino: %.4f\n", camino_promedio))
cat(sprintf("   - Diámetro de la red: %d\n", diametro))
# 4. Grado de centralidad
grados <- degree(red)
grado_promedio <- mean(grados)
grado_max <- max(grados)
grado_min <- min(grados)
cat(sprintf("\n4. GRADO DE CENTRALIDAD:\n"))
cat(sprintf("   - Grado promedio: %.4f\n", grado_promedio))
cat(sprintf("   - Grado máximo: %d\n", grado_max))
cat(sprintf("   - Grado mínimo: %d\n", grado_min))
cat(sprintf("   - Desviación estándar: %.4f\n", sd(grados)))
# 5. Coeficiente de agrupamiento (clustering)
clustering_global <- transitivity(red, type = "global")
clustering_promedio <- transitivity(red, type = "average")
clustering_local <- transitivity(red, type = "local")
cat(sprintf("\n5. COEFICIENTE DE AGRUPAMIENTO (CLUSTERING):\n"))
cat(sprintf("   - Clustering global: %.4f\n", clustering_global))
cat(sprintf("   - Clustering promedio: %.4f\n", clustering_promedio))
cat(sprintf("   - Clustering local (rango): %.4f - %.4f\n",
min(clustering_local, na.rm = TRUE),
max(clustering_local, na.rm = TRUE)))
# 6. Otras métricas de centralidad
betweenness_promedio <- mean(betweenness(red))
closeness_promedio <- mean(closeness(red))
cat(sprintf("\n6. OTRAS MÉTRICAS DE CENTRALIDAD:\n"))
cat(sprintf("   - Betweenness promedio: %.4f\n", betweenness_promedio))
cat(sprintf("   - Closeness promedio: %.4f\n", closeness_promedio))
# 7. Propiedades de red libre de escala
cat(sprintf("\n7. CARACTERÍSTICAS DE RED LIBRE DE ESCALA:\n"))
cat(sprintf("   - Número de hubs (grado > promedio): %d\n",
sum(grados > grado_promedio)))
cat(sprintf("   - Proporción de hubs: %.2f%%\n",
100 * sum(grados > grado_promedio) / n_nodos))
cat("\n==========================================\n")
